<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init vite@latest // 初始化项目</span><br><span class="line">npm install // or npm i 下载相关依赖，生成node_modules</span><br><span class="line">npm run dev // 启动项目</span><br><span class="line">npm init vue@latest //初始化项目，配置更全面</span><br></pre></td></tr></table></figure><p><strong>node.js 源码</strong></p><p>v8、libnv和第三方库构成</p><h3 id="二、认识目录-amp-SFC-amp-插件"><a href="#二、认识目录-amp-SFC-amp-插件" class="headerlink" title="二、认识目录 &amp; SFC &amp; 插件"></a>二、认识目录 &amp; SFC &amp; 插件</h3><p><strong>认识目录</strong></p><ol><li>pubilc：静态资源，不会被vite编译</li><li>src<ol><li>assets：较小静态资源，打包成base64，</li><li>components</li><li>App.vue：全局入口文件</li><li>main.ts：全局TS文件，全局的样式、API</li><li>vite.env.d.ts：声明文件扩充</li></ol></li><li>index.html</li><li>package.json：依赖</li><li>tsconfig.json：是TS配置文件</li><li>vite.config.ts：是vite配置文件</li></ol><p><strong>SFC</strong></p><ol><li>script：变量</li><li>template：标签</li><li>style：样式</li></ol><p><strong>插件</strong></p><ol><li>volar</li><li>Vue Language Feature</li></ol><p><strong><code>npm run dev</code>过程</strong></p><ol><li>package.json -&gt; script -&gt; dev -&gt; vite</li><li>node_modules -&gt; vite -&gt; bin</li></ol><h3 id="三、模板语法-amp-Vue指令"><a href="#三、模板语法-amp-Vue指令" class="headerlink" title="三、模板语法 &amp; Vue指令"></a>三、模板语法 &amp; Vue指令</h3><ol><li><p>vue2：option api</p></li><li><p>vue3：setup函数模式</p><ol><li><p>setup</p><p>1. </p></li><li><p>setup语法糖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>Vue指令</strong></p><p>v- 开头都是 vue 的指令</p><ol><li><p>v-text 用来显示文本</p></li><li><p>v-html 用来展示富文本</p></li><li><p>v-if 用来控制元素的显示隐藏（切换真假DOM）</p></li><li><p>v-else-if 表示 v-if 的“else if 块”。可以链式调用</p></li><li><p>v-else v-if条件收尾语句</p></li><li><p>v-show 用来控制元素的显示隐藏（display none block Css切换）</p></li><li><p>v-on 简写@ 用来给元素添加事件</p></li><li><p>v-bind 简写:  用来绑定元素的属性Attr</p></li><li><p>v-model 双向绑定</p></li><li><p>v-for 用来遍历元素</p></li><li><p>v-on修饰符 冒泡案例</p></li><li><p>v-once 性能优化只渲染一次</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>暑期实习｜蚂蚁后端一面：深入源码和操作系统</title>
      <link href="/post/a6f5b56e.html"/>
      <url>/post/a6f5b56e.html</url>
      
        <content type="html"><![CDATA[<h1 id="暑期实习｜蚂蚁后端一面：深入源码和操作系统"><a href="#暑期实习｜蚂蚁后端一面：深入源码和操作系统" class="headerlink" title="暑期实习｜蚂蚁后端一面：深入源码和操作系统"></a>暑期实习｜蚂蚁后端一面：深入源码和操作系统</h1><h2 id="1-Java的聊天室是怎么做的？"><a href="#1-Java的聊天室是怎么做的？" class="headerlink" title="1.Java的聊天室是怎么做的？"></a>1.Java的聊天室是怎么做的？</h2><p>一个Java聊天室通常由两部分组成：服务器端和客户端。</p><ol><li><strong>服务器端（Server）</strong>：就像一个聊天室的控制中心。它会等待客户端的连接，并负责接收和发送消息。</li><li><strong>客户端（Client）</strong>：就像聊天室的参与者。它会连接到服务器，并能够发送消息给服务器，同时接收其他客户端发送的消息。</li></ol><p>在服务器端，我们使用一个专门的类叫做<code>ServerSocket</code>来监听一个特定的端口。当客户端想要加入聊天室时，它们会尝试连接到服务器上的这个端口。一旦有客户端连接成功，服务器就会为它创建一个新的线程来处理它的请求。这个线程会不断地接收该客户端发送的消息，并处理它们。服务器可以将接收到的消息广播给所有连接到它的客户端。</p><p>在客户端，我们使用普通的<code>Socket</code>来连接到服务器上的端口。一旦连接成功，客户端就可以通过这个Socket发送消息给服务器，并且也可以从服务器接收其他客户端发送的消息。这样，多个客户端就可以在服务器的协调下进行互相交流了。</p><h2 id="2-工厂模式分成几种类型？"><a href="#2-工厂模式分成几种类型？" class="headerlink" title="2.工厂模式分成几种类型？"></a>2.工厂模式分成几种类型？</h2><p>工厂模式是一种创建型设计模式，用于封装对象的创建过程。根据实现方式和结构的不同，工厂模式可以分为三种主要类型：</p><ol><li><strong>简单工厂模式（Simple Factory Pattern）</strong>： 在简单工厂模式中，有一个专门的工厂类负责根据给定的参数来创建对象。客户端只需要知道要创建的对象的类型，而不需要知道创建对象的具体细节。简单工厂模式将对象的创建过程从客户端代码中解耦出来，使得客户端代码更加简洁。但是，简单工厂模式违反了开闭原则，因为每次新增加一个产品类都需要修改工厂类的代码。</li><li><strong>工厂方法模式（Factory Method Pattern）</strong>： 工厂方法模式定义了一个抽象的工厂接口，其中包含一个用于创建对象的抽象方法。具体的产品类都实现这个接口，并提供自己的工厂类来创建自己的对象。这样每个产品类都有一个对应的工厂类，从而实现了对象的创建和具体产品类的解耦。工厂方法模式符合开闭原则，因为新增加一个产品类只需要添加一个相应的具体工厂类即可，不需要修改原有代码。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>： 抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式通常由一个抽象工厂类和多个具体工厂类组成，每个具体工厂类负责创建一组相关的产品对象。抽象工厂模式将一组相关的产品对象的创建过程封装在一起，使得客户端可以通过一个接口来创建一整套产品对象。</li></ol><h2 id="3-用编译原理实现加减乘除"><a href="#3-用编译原理实现加减乘除" class="headerlink" title="3.用编译原理实现加减乘除"></a>3.用编译原理实现加减乘除</h2><p>要用编译原理实现加减乘除，你可以考虑以下步骤：</p><ol><li><strong>词法分析（Lexical Analysis）</strong>：将输入的表达式分解为一个个的词法单元（token），如运算符、操作数等。</li><li><strong>语法分析（Syntax Analysis）</strong>：根据词法单元构建抽象语法树（Abstract Syntax Tree，AST），以表示表达式的结构。你可以使用递归下降解析器或者其他解析器来实现。</li><li><strong>语义分析（Semantic Analysis）</strong>：对抽象语法树进行语义分析，确保表达式的合法性。例如，检查除数是否为零等错误。</li><li><strong>生成中间代码（Intermediate Code Generation）</strong>：将抽象语法树转换为中间代码，例如逆波兰表达式（Reverse Polish Notation，RPN）。</li><li><strong>解释执行或生成目标代码（Interpretation or Code Generation）</strong>：根据中间代码执行相应的操作，计算表达式的值。如果你想生成目标代码，可以进一步将中间代码转换为机器代码或者其他可执行的形式。</li></ol><h2 id="4-看过Spring的书吗，讲讲内容"><a href="#4-看过Spring的书吗，讲讲内容" class="headerlink" title="4.看过Spring的书吗，讲讲内容"></a>4.看过Spring的书吗，讲讲内容</h2><p>Spring是一个轻量级的Java开发框架，主要用于简化企业级应用开发。</p><p>它提供了IOC（控制反转）和AOP（面向切面编程）的核心功能，用于管理对象之间的依赖关系和横切关注点。</p><p>Spring还提供了数据访问、事务管理、Web应用开发等模块化的解决方案。</p><h2 id="5-Linux分成哪些流"><a href="#5-Linux分成哪些流" class="headerlink" title="5.Linux分成哪些流"></a>5.Linux分成哪些流</h2><ol><li><strong>标准输入流（stdin）</strong>： 标准输入流通常代表从键盘输入的数据。在命令行中，如果没有重定向输入，命令将默认从标准输入流中读取数据。在程序中，通常使用标准输入流来接收用户的输入。</li><li><strong>标准输出流（stdout）</strong>： 标准输出流通常代表向屏幕输出的数据。在命令行中，如果没有重定向输出，命令将默认将输出写入到标准输出流中。在程序中，通常使用标准输出流来输出程序的结果和信息。</li><li><strong>标准错误流（stderr）</strong>： 标准错误流用于输出错误消息和诊断信息。与标准输出流不同，标准错误流的内容不会被重定向到同一个地方，通常会将它们显示在屏幕上，这样可以使得错误消息更容易被用户注意到。</li><li><strong>管道流（Pipes）</strong>： 管道流允许将一个命令的输出直接作为另一个命令的输入。在命令行中，可以使用竖线符号（|）来创建管道流。通过管道流，可以将多个命令串联起来，从而实现更复杂的数据处理操作。</li><li><strong>文件流（File Streams）</strong>： 文件流是指通过文件进行输入输出的流。在Linux系统中，可以通过文件流来读取和写入文件中的数据。在命令行中，可以使用重定向符号（&lt;、&gt;、&gt;&gt;）来将命令的输入输出重定向到文件中。</li></ol><h2 id="6-加减幂怎么实现"><a href="#6-加减幂怎么实现" class="headerlink" title="6.加减幂怎么实现"></a>6.加减幂怎么实现</h2><h2 id="7-看过哪些源码，怎么实现的"><a href="#7-看过哪些源码，怎么实现的" class="headerlink" title="7.看过哪些源码，怎么实现的"></a>7.看过哪些源码，怎么实现的</h2><p>建议看看Java核心库、Spring框架、Linux内核、数据库系统等。</p><h2 id="8-多核-CPU-改了一个-CPU-的内容，其他-CPU-怎么发现"><a href="#8-多核-CPU-改了一个-CPU-的内容，其他-CPU-怎么发现" class="headerlink" title="8.多核 CPU 改了一个 CPU 的内容，其他 CPU 怎么发现"></a>8.多核 CPU 改了一个 CPU 的内容，其他 CPU 怎么发现</h2><p>在多核CPU中，通常会存在一些机制来保证各个核心之间的一致性和同步。其中一个常见的机制是缓存一致性协议，比如MESI（Modified, Exclusive, Shared, Invalid）协议。</p><p>在MESI协议中，每个缓存行都有四种状态：</p><ul><li>Modified（已修改）：表示缓存行已被当前核心修改，但尚未写回到内存。</li><li>Exclusive（独占）：表示缓存行只存在于当前核心的缓存中，且未被修改。</li><li>Shared（共享）：表示缓存行在多个核心的缓存中存在且相同，未被修改。</li><li>Invalid（无效）：表示缓存行无效，不可用。</li></ul><p>当一个CPU修改了一个缓存行中的内容时，根据MESI协议，它会将该缓存行状态从Exclusive或Shared改为Modified，并且会向其他拥有相同缓存行的CPU发送信号，通知它们将该缓存行状态改为Invalid，从而保持一致性。</p><p>因此，其他CPU会通过缓存一致性协议中的机制，如总线嗅探或者其他通信机制，检测到对应缓存行的状态发生了改变，并更新自己的缓存</p><h2 id="9-WebSocket怎么实现的"><a href="#9-WebSocket怎么实现的" class="headerlink" title="9.WebSocket怎么实现的"></a>9.WebSocket怎么实现的</h2><p><code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，允许在客户端和服务器之间进行实时数据传输。下面是 <code>WebSocket</code> 如何实现的简要概述：</p><ol><li><strong>建立握手（Handshake）</strong>： 客户端通过发送一个 HTTP 请求给服务器来请求建立 <code>WebSocket</code> 连接。该请求包含一些特殊的头部信息，如 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>。服务器收到这个请求后，如果支持 <code>WebSocket</code>，就会响应一个 HTTP 101 状态码（Switching Protocols），表示协议切换成功，之后便进入了 <code>WebSocket</code> 协议的通信状态。</li><li><strong>通信（Communication）</strong>： 建立了 <code>WebSocket</code> 连接之后，客户端和服务器就可以通过这个连接进行实时通信了。双方可以发送文本或二进制数据帧，这些帧会经过 <code>WebSocket</code> 协议封装和解封装。<code>WebSocket</code> 协议提供了一种轻量级的通信方式，使得客户端和服务器可以通过一个持久化的连接进行双向数据传输，而无需频繁地发起 HTTP 请求和响应。</li><li><strong>保持连接（Keep-Alive）</strong>： <code>WebSocket</code> 连接是持久化的，因此在连接建立后，客户端和服务器之间的通信通常会保持活跃状态。双方可以定期发送心跳帧来确保连接的活性，同时也可以根据需要随时关闭连接。</li><li><strong>关闭连接（Closing Connection）</strong>： 客户端或服务器可以通过发送一个特殊的关闭帧来关闭 <code>WebSocket</code> 连接。一旦收到关闭帧，另一方也会发送一个相应的关闭帧，并且立即关闭连接。</li></ol><p>总的来说，<code>WebSocket</code> 协议通过一次握手建立连接，之后就可以通过一个持久化的连接进行实时通信，这使得它成为了一种高效、轻量级的实时通信方案。</p><h2 id="10-操作系统位数和CPU位数的关系"><a href="#10-操作系统位数和CPU位数的关系" class="headerlink" title="10.操作系统位数和CPU位数的关系"></a>10.操作系统位数和CPU位数的关系</h2><p>操作系统位数和 CPU 位数之间的关系通常体现在操作系统的兼容性和性能上。下面是它们之间的关系：</p><ol><li><strong>位数定义</strong>：<ul><li>操作系统的位数指的是操作系统在处理地址时使用的位数，通常表示操作系统能够寻址的内存地址的位数。比如，64位操作系统可以寻址的内存地址范围更广，可以支持更大的内存空间。</li><li>CPU 的位数指的是 CPU 寄存器的位数，通常表示 CPU 在一次指令操作中能够处理的数据位数。比如，64位 CPU 可以在一次指令操作中处理 64 位的数据。</li></ul></li><li><strong>兼容性</strong>：<ul><li>64位操作系统可以运行在 64位 CPU 上，也可以运行在 32位 CPU 上（在兼容模式下）。</li><li>32位操作系统只能运行在 32位 CPU 上。</li></ul></li><li><strong>性能</strong>：<ul><li>当一个应用程序在与其匹配的操作系统和 CPU 上运行时，通常会有更好的性能，因为它可以利用 CPU 的所有功能。</li><li>在相同的硬件上，64位操作系统通常能够更好地利用大于4GB的内存，提供更好的性能和更好的系统稳定性。</li></ul></li></ol><p>总的来说，操作系统位数和 CPU 位数之间的关系主要体现在兼容性和性能上。选择操作系统和 CPU 时，需要考虑它们之间的匹配关系，以获得最佳的性能和兼容性。</p><h2 id="11-北向接口和南向接口-哪个存储缓存"><a href="#11-北向接口和南向接口-哪个存储缓存" class="headerlink" title="11.北向接口和南向接口 哪个存储缓存"></a>11.北向接口和南向接口 哪个存储缓存</h2><p>在计算机网络和系统架构中，”北向接口”和”南向接口”是两个常见的术语，它们指的是不同层次或方向上的接口。</p><ol><li><strong>北向接口（Northbound Interface）</strong>：<ul><li>北向接口是指系统或组件向更高层次的系统或组件提供的接口。通常，这个更高层次的系统或组件是用户或应用程序。因此，北向接口是系统对外部世界的接口。</li><li>在网络领域，北向接口通常指的是设备或系统向网络管理系统(NMS)或上层管理系统提供的接口，用于获取网络状态信息、配置网络设备等。</li><li>在存储领域，北向接口可以指存储系统向上层应用程序提供的接口，用于访问存储资源、管理存储策略等。</li></ul></li><li><strong>南向接口（Southbound Interface）</strong>：<ul><li>南向接口是指系统或组件向更低层次的系统或组件提供的接口。通常，这个更低层次的系统或组件是硬件、底层服务或操作系统。</li><li>在网络领域，南向接口通常指的是设备向底层网络设备(如交换机、路由器)提供的接口，用于配置、管理和监控设备的硬件和软件参数。</li><li>在存储领域，南向接口可以指存储系统向底层存储设备(如硬盘、固态硬盘)或存储控制器提供的接口，用于数据的读写、存储管理等。</li></ul></li></ol><h2 id="12-操作系统底层原理"><a href="#12-操作系统底层原理" class="headerlink" title="12.操作系统底层原理"></a>12.操作系统底层原理</h2><p>操作系统底层原理涉及多个方面，包括操作系统的架构、调度算法、内存管理、文件系统、设备管理等。以下是操作系统底层原理的一些主要内容：</p><ol><li><strong>内核与用户空间</strong>： 操作系统通常由内核和用户空间组成。内核是操作系统的核心部分，负责管理系统的资源和提供系统调用接口；而用户空间是操作系统提供给应用程序的环境，应用程序在用户空间运行，通过系统调用接口访问内核功能。</li><li><strong>进程管理</strong>： 操作系统通过进程管理来实现多任务处理。进程是程序的执行实例，操作系统负责创建、调度、终止和管理进程。进程调度算法决定了进程如何分配CPU时间，常见的调度算法包括先来先服务（FCFS）、短作业优先（SJF）、时间片轮转等。</li><li><strong>内存管理</strong>： 内存管理是操作系统管理系统内存的过程，包括内存分配、地址映射、内存保护和内存回收等。内存管理的主要目标是提高内存利用率、减少内存碎片、保护进程的地址空间等。</li><li><strong>文件系统</strong>： 文件系统是操作系统管理存储设备上文件和目录的方式。文件系统负责文件的存储、组织、访问和管理。常见的文件系统包括FAT、NTFS、EXT等。</li><li><strong>设备管理</strong>： 设备管理是操作系统管理计算机硬件设备的过程，包括设备驱动程序的加载、设备的初始化、设备的控制和数据传输等。操作系统通过设备管理层抽象出统一的设备接口，使得应用程序可以统一地访问各种硬件设备。</li><li><strong>中断处理</strong>： 中断是指硬件或软件发出的信号，用于通知操作系统发生了某种事件。操作系统通过中断处理程序来响应中断，并根据中断类型执行相应的处理操作。</li></ol><p>这些底层原理共同构成了操作系统的核心功能和特性，对于理解操作系统的工作原理和实现具有重要意义。</p><h2 id="13-操作系统什么场景使用多线程，怎么设置"><a href="#13-操作系统什么场景使用多线程，怎么设置" class="headerlink" title="13.操作系统什么场景使用多线程，怎么设置"></a>13.操作系统什么场景使用多线程，怎么设置</h2><p>多线程在操作系统中的应用场景非常广泛，主要包括以下几个方面：</p><ol><li><strong>并发处理</strong>：多线程可以用于同时处理多个任务，提高系统的并发性能。例如，在服务器端应用中，可以使用多线程来处理多个客户端的请求，实现并发访问。</li><li><strong>异步编程</strong>：多线程可以用于实现异步编程模型，提高系统的响应速度。例如，在图形界面(GUI)应用中，可以使用多线程来处理用户界面的事件，保持界面的响应性。</li><li><strong>并行计算</strong>：多线程可以用于利用多核CPU的并行计算能力，提高计算性能。例如，在科学计算、图像处理等领域，可以使用多线程并行处理大规模数据。</li><li><strong>资源共享</strong>：多线程可以用于实现共享资源的并发访问和管理。例如，在数据库系统中，可以使用多线程来处理对共享数据库的查询和更新操作。</li></ol><p>要设置多线程，通常需要以下步骤：</p><ol><li><strong>创建线程</strong>：在程序中创建多个线程，可以使用操作系统提供的线程库或编程语言提供的线程支持。例如，在 Java 中可以使用 Thread 类或 Runnable 接口创建线程。</li><li><strong>线程调度</strong>：操作系统负责对线程进行调度和管理，以确保它们能够按照预期的方式运行。线程调度器会根据线程的优先级、状态等因素来确定线程的执行顺序。</li><li><strong>线程同步</strong>：在多线程环境中，可能会出现共享资源的并发访问问题，需要使用同步机制来确保多个线程之间的数据一致性和互斥访问。常见的同步机制包括锁、信号量、条件变量等。</li><li><strong>异常处理</strong>：在多线程程序中，可能会出现线程抛出异常而导致程序异常终止的情况，需要对异常进行适当的处理和捕获，以确保程序的稳定性和可靠性。</li></ol><p>通过合理地设置多线程，可以充分利用多核CPU的计算能力，提高系统的性能和响应速度，同时也需要注意处理多线程并发访问和同步的问题，以确保程序的正确性和稳定性。</p><h2 id="14-BeanFactory怎么做的，看过源码吗"><a href="#14-BeanFactory怎么做的，看过源码吗" class="headerlink" title="14.BeanFactory怎么做的，看过源码吗"></a>14.BeanFactory怎么做的，看过源码吗</h2><p><code>BeanFactory</code> 是 Spring 框架中的一个核心接口，用于管理和控制 Bean 对象的创建、生命周期管理等。<code>BeanFactory</code> 提供了一种解耦合的方式来管理应用程序中的对象依赖关系。</p><p><code>BeanFactory</code> 的主要功能包括：</p><ul><li>实例化 Bean：根据配置文件或注解，实例化应用程序中的各种 Bean 对象。</li><li>Bean 生命周期管理：管理 Bean 对象的生命周期，包括初始化、销毁等。</li><li>Bean 的依赖注入：处理 Bean 对象之间的依赖关系，实现依赖注入。</li></ul><p>在 Spring 框架中，<code>BeanFactory</code> 接口有多个实现类，其中最常用的是 <code>ApplicationContext</code> 接口的实现类。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个子接口，提供了更丰富的功能和更便捷的用法，通常也是更推荐使用的。</p><p>针对 <code>BeanFactory</code> 的具体实现，Spring 使用了反射机制、配置解析和依赖注入等技术来实现。具体来说，Spring 会通过解析配置文件（如 XML 文件）或扫描注解来获取 Bean 的定义和依赖关系，然后通过反射机制实例化 Bean 对象，并通过依赖注入来处理 Bean 之间的依赖关系。Spring 还会管理 Bean 的生命周期，执行初始化和销毁操作。</p><p>要深入了解 <code>BeanFactory</code> 的实现原理，可以阅读 Spring 框架的源代码。Spring 框架是一个开源项目，其源代码可以在其官方网站或 GitHub 上找到并下载。通过阅读源代码，可以更深入地理解 Spring 框架的设计思想和实现方式。</p><h2 id="15-ThreadLocal源码"><a href="#15-ThreadLocal源码" class="headerlink" title="15.ThreadLocal源码"></a>15.ThreadLocal源码</h2><p><code>ThreadLocal</code> 的源码主要实现了线程局部变量的功能。它提供了一种让每个线程都可以独立地维护自己的变量副本的机制。通过 <code>ThreadLocal</code>，我们可以在多线程环境下安全地存储和访问线程私有数据。下面是 <code>ThreadLocal</code> 的简要源码剖析以及它的实现原理：</p><ol><li><strong>ThreadLocal 类定义</strong>： <code>ThreadLocal</code> 类定义了一个静态内部类 <code>ThreadLocalMap</code>，用于存储线程局部变量的值。<code>ThreadLocal</code> 实例本身是一个线程安全的类。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的变量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前线程的变量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>ThreadLocalMap 类定义</strong>： <code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类，用于实际存储线程局部变量的值。它是一个自定义的散列表，以 <code>ThreadLocal</code> 实例作为键，存储对应的值。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codestatic <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前 ThreadLocal 实例在当前线程中的变量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前 ThreadLocal 实例和对应的变量值存储到当前线程的 ThreadLocalMap 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理:</p><ul><li>每个 <code>ThreadLocal</code> 实例都有一个唯一的 <code>ThreadLocalHashCode</code>，用于在 <code>ThreadLocalMap</code> 中定位对应的值。</li><li>当调用 <code>ThreadLocal</code> 的 get 方法时，会先获取当前线程的 <code>ThreadLocalMap</code>，然后根据 <code>ThreadLocal</code> 实例定位到对应的 Entry，从而获取变量值。</li><li>当调用 <code>ThreadLocal</code> 的 set 方法时，会先获取当前线程的 <code>ThreadLocalMap</code>，然后将 <code>ThreadLocal</code> 实例和对应的值存储到 <code>ThreadLocalMap</code> 中。</li></ul><p><code>ThreadLocal</code> 的实现原理简单地通过每个线程都维护一个 <code>ThreadLocalMap</code>，然后根据 <code>ThreadLocal</code> 实例将变量值存储到对应的 Entry 中，从而实现了每个线程都拥有自己独立的变量副本的机制。值得注意的是，由于 <code>ThreadLocalMap</code> 中的 Entry 引用了 <code>ThreadLocal</code> 实例，如果 <code>ThreadLocal</code> 实例不再被使用，但对应的线程仍然存在，则可能会导致内存泄漏，因此在使用 <code>ThreadLocal</code> 时需要谨慎管理。</p><h2 id="16-Future除了接受异步任务结果，还能干嘛"><a href="#16-Future除了接受异步任务结果，还能干嘛" class="headerlink" title="16.Future除了接受异步任务结果，还能干嘛"></a>16.Future除了接受异步任务结果，还能干嘛</h2><p>Future 是 Java 并发编程中用于表示异步计算结果的接口。除了可以获取异步任务的结果，Future 还提供了<strong>判断任务是否完成</strong>、<strong>阻塞等待任务完成</strong>、<strong>异常处理</strong>以及<strong>取消任务</strong>等方法。这使我们能够更灵活地控制异步任务的执行和结果处理。</p><h2 id="17-Fork-x2F-Join与普通的线程池有什么区别？"><a href="#17-Fork-x2F-Join与普通的线程池有什么区别？" class="headerlink" title="17.Fork&#x2F;Join与普通的线程池有什么区别？"></a>17.Fork&#x2F;Join与普通的线程池有什么区别？</h2><ol><li><strong>任务分割与合并</strong>：<ul><li>Fork&#x2F;Join 框架主要用于处理可分解的任务，它将一个大任务分割成多个小任务，然后将这些小任务分配给多个线程执行，并最终将各个小任务的结果合并起来得到最终结果。这种任务的分割和合并是 Fork&#x2F;Join 框架的核心特性。</li><li>普通的线程池则主要用于处理独立的任务，它将任务提交给线程池后，由线程池中的线程按照指定的策略执行任务，但不会对任务进行分割和合并操作。</li></ul></li><li><strong>工作窃取算法</strong>：<ul><li>Fork&#x2F;Join 框架使用工作窃取算法（Work-Stealing Algorithm）来提高线程利用率和任务执行效率。在 Fork&#x2F;Join 框架中，每个线程都有自己的工作队列，当一个线程执行完自己队列中的任务后，会去其他线程的队列中“窃取”任务来执行，以保持线程的忙碌状态，提高整个系统的并行度。</li><li>而普通的线程池中，每个线程都是从线程池的任务队列中获取任务来执行，不存在工作窃取的概念。</li></ul></li><li><strong>任务类型</strong>：<ul><li>Fork&#x2F;Join 框架更适合处理递归、可分解的任务，如归并排序、快速排序、斐波那契数列等。这些任务可以被分割成多个子任务，并行执行，最后合并结果。</li><li>普通的线程池更适合处理独立的、相互不依赖的任务，如网络请求、IO操作等。</li></ul></li></ol><p>总的来说，Fork&#x2F;Join 框架相比普通的线程池在任务的分割与合并、工作窃取算法和适用任务类型等方面有着不同的设计思路和应用场景。</p><h2 id="18-ConcurrentHashMap源码"><a href="#18-ConcurrentHashMap源码" class="headerlink" title="18.ConcurrentHashMap源码"></a>18.ConcurrentHashMap源码</h2><p><code>ConcurrentHashMap</code> 是 Java 中用于多线程环境下安全地进行并发访问的哈希表实现。它提供了线程安全的并发操作，同时也提供了比 <code>Hashtable</code> 和同步的 <code>HashMap</code> 更高的性能。</p><p><code>ConcurrentHashMap</code> 的主要特点和实现包括：</p><ol><li><strong>线程安全</strong>： <code>ConcurrentHashMap</code> 提供了对并发访问的支持，多个线程可以同时对 <code>ConcurrentHashMap</code> 进行读取和部分写入操作，而不会出现数据不一致的情况。它采用了分段锁的方式来提高并发性能。</li><li><strong>分段锁</strong>： <code>ConcurrentHashMap</code> 内部维护了一定数量的 Segment（段），每个 Segment 就是一个类似于 <code>HashMap</code> 的哈希表，它独立于其他 Segment，拥有自己的锁。这样，在并发访问时，只有对应的 Segment 被加锁，其他 Segment 不受影响，从而减少了锁的竞争，提高了并发性能。</li><li><strong>高性能</strong>： <code>ConcurrentHashMap</code> 的分段锁设计使得多个线程可以并行地对不同的 Segment 进行操作，从而提高了并发性能。而且，在读操作上不会阻塞，多个线程可以同时读取数据，只有在写操作时才需要进行锁的竞争。</li><li><strong>调整容量</strong>： <code>ConcurrentHashMap</code> 在容量达到一定阈值时会自动扩容，而且在扩容时不会阻塞其他线程的读操作，只会影响到写操作的性能。它采用了一种称为 “分段锁扩容” 的策略，即只会对扩容的那个 Segment 进行加锁，其他 Segment 不受影响。</li><li><strong>迭代安全</strong>： <code>ConcurrentHashMap</code> 在迭代时也是安全的，即使在迭代过程中有其他线程对 <code>ConcurrentHashMap</code> 进行修改，也不会抛出 <code>ConcurrentModificationException</code> 异常。这是因为 <code>ConcurrentHashMap</code> 在内部采用了一种称为 “快速失败迭代器” 的机制，它在迭代过程中使用了一些技巧来确保迭代的一致性和安全性。</li></ol><p><code>ConcurrentHashMap</code> 实现了在多线程环境下安全地进行并发访问的哈希表，并通过分段锁等机制提高了并发性能，同时也提供了高性能的读操作、自动扩容、迭代安全等特性。</p><h2 id="19-String源码怎么设计的，与操作系统相关联的设计"><a href="#19-String源码怎么设计的，与操作系统相关联的设计" class="headerlink" title="19.String源码怎么设计的，与操作系统相关联的设计"></a>19.String源码怎么设计的，与操作系统相关联的设计</h2><p><code>String</code> 类在 Java 中是一个不可变的类，它表示字符串对象。在 Java 中，字符串是一种常见的数据类型，<code>String</code> 类提供了许多方法来操作字符串。<code>String</code> 类的设计与操作系统的设计没有直接关联，因为它是 Java 语言中的一个标准库类，而不是操作系统的一部分。</p><h2 id="20-基于Socket设计了哪些系统？怎么实现的"><a href="#20-基于Socket设计了哪些系统？怎么实现的" class="headerlink" title="20.基于Socket设计了哪些系统？怎么实现的"></a>20.基于Socket设计了哪些系统？怎么实现的</h2><p>基于 Socket 可以设计各种类型的系统，包括但不限于：</p><ol><li><strong>网络通信系统</strong>： 可以设计各种类型的网络通信系统，包括即时通讯系统、聊天应用、在线游戏、远程控制系统等。通过 Socket 建立客户端与服务器之间的通信连接，实现数据的双向传输。</li><li><strong>文件传输系统</strong>： 可以设计文件传输系统，用于在客户端和服务器之间传输文件。通过 Socket 实现客户端和服务器之间的文件传输，包括上传、下载、文件共享等功能。</li><li><strong>远程监控和控制系统</strong>： 可以设计远程监控和控制系统，用于监控和控制远程设备或系统。通过 Socket 建立客户端与监控设备或控制中心之间的连接，实现数据的实时监控和远程控制。</li><li><strong>分布式计算系统</strong>： 可以设计分布式计算系统，用于将计算任务分发到多台计算节点上进行并行计算。通过 Socket 实现计算节点之间的通信和数据交换，协调各个计算节点的工作。</li><li><strong>远程调用系统</strong>： 可以设计远程调用系统，用于实现跨网络的方法调用和远程服务调用。通过 Socket 建立客户端和服务端之间的连接，实现客户端对服务端方法的调用和数据传输。</li></ol><p>实现这些系统时，通常需要考虑以下几个方面：</p><ul><li><strong>通信协议的设计</strong>：定义通信协议，包括数据格式、消息格式、通信方式等。</li><li><strong>Socket 编程</strong>：使用 Java、Python、C++ 等编程语言进行 Socket 编程，实现客户端和服务器之间的通信连接。</li><li><strong>并发处理</strong>：处理多个客户端同时连接的情况，采用多线程、线程池等技术实现并发处理。</li><li><strong>安全性和可靠性</strong>：考虑数据的安全传输和通信的可靠性，采用加密算法、认证机制、重传机制等保障通信的安全性和可靠性。</li></ul><p>这些系统通过 Socket 进行网络通信，实现数据的发送和接收。具体的实现方式会根据系统的需求和架构而有所不同，但通常包括创建 <code>ServerSocket</code> 监听端口、建立 Socket 连接、发送和接收数据等步骤。</p><h2 id="21-除了Java还会哪些语言吗？"><a href="#21-除了Java还会哪些语言吗？" class="headerlink" title="21.除了Java还会哪些语言吗？"></a>21.除了Java还会哪些语言吗？</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习入门</title>
      <link href="/post/54ae0472.html"/>
      <url>/post/54ae0472.html</url>
      
        <content type="html"><![CDATA[<h4 id="神经网络对象"><a href="#神经网络对象" class="headerlink" title="神经网络对象"></a>神经网络对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = Sequential() #创建一个神经网络对象</span><br><span class="line">\#添加一个卷积层，传入固定宽高三通道的图片，以32种不同的卷积核构建32张特征图，</span><br><span class="line">\# 卷积核大小为3*3，构建特征图比例和原图相同，激活函数为relu函数。</span><br><span class="line">model.add(Conv2D(input_shape=(IMG_W,IMG_H,3),filters=32,kernel_size=3,padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;))</span><br><span class="line">\#再次构建一个卷积层</span><br><span class="line">model.add(Conv2D(filters=32,kernel_size=3,padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;))</span><br><span class="line">\#构建一个池化层，提取特征，池化层的池化窗口为2*2，步长为2。</span><br><span class="line">model.add(MaxPool2D(pool_size=2,strides=2))</span><br><span class="line">\#继续构建卷积层和池化层，区别是卷积核数量为64。</span><br><span class="line">model.add(Conv2D(filters=64,kernel_size=3,padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;))</span><br><span class="line">model.add(Conv2D(filters=64,kernel_size=3,padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;))</span><br><span class="line">model.add(MaxPool2D(pool_size=2,strides=2))</span><br><span class="line">\#继续构建卷积层和池化层，区别是卷积核数量为128。</span><br><span class="line">model.add(Conv2D(filters=128,kernel_size=3,padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;))</span><br><span class="line">model.add(Conv2D(filters=128,kernel_size=3,padding=&#x27;same&#x27;,activation=&#x27;relu&#x27;))</span><br><span class="line">model.add(MaxPool2D(pool_size=2, strides=2))</span><br><span class="line">model.add(Flatten()) #数据扁平化</span><br><span class="line">model.add(Dense(128,activation=&#x27;relu&#x27;)) #构建一个具有128个神经元的全连接层</span><br><span class="line">model.add(Dense(64,activation=&#x27;relu&#x27;)) #构建一个具有64个神经元的全连接层</span><br><span class="line">model.add(Dropout(DROPOUT_RATE)) #加入dropout，防止过拟合。</span><br><span class="line">model.add(Dense(CLASS,activation=&#x27;softmax&#x27;)) #输出层，一共3个神经元，对应3个分类</span><br><span class="line">adam = Adam(lr=LEARNING_RATE) #创建Adam优化器</span><br><span class="line">model.compile(optimizer=adam,loss=&#x27;categorical_crossentropy&#x27;,metrics=[&#x27;accuracy&#x27;]) #使用交叉熵代价函数，adam优化器优化模型，并提取准确率</span><br><span class="line">train_generator = train_datagen.flow_from_directory( #设置训练集迭代器</span><br><span class="line">  TRAIN_PATH, #训练集存放路径</span><br><span class="line">  target_size=(IMG_W,IMG_H), #训练集图片尺寸</span><br><span class="line">  batch_size=BATCH_SIZE #训练集批次</span><br><span class="line">  )</span><br><span class="line">test_generator = test_datagen.flow_from_directory( #设置测试集迭代器</span><br><span class="line">  TEST_PATH, #测试集存放路径</span><br><span class="line">  target_size=(IMG_W,IMG_H), #测试集图片尺寸</span><br><span class="line">  batch_size=BATCH_SIZE, #测试集批次</span><br><span class="line">  )</span><br><span class="line">print(train_generator.class_indices) #打印迭代器分类</span><br><span class="line">try:</span><br><span class="line">  model = load_model(&#x27;&#123;&#125;.h5&#x27;.format(SAVE_PATH)) #尝试读取训练好的模型，再次训练</span><br><span class="line">  print(&#x27;model upload,start training!&#x27;)</span><br><span class="line">except:</span><br><span class="line">  print(&#x27;not find model,start training&#x27;) #如果没有训练过的模型，则从头开始训练</span><br><span class="line">model.fit_generator( #模型拟合</span><br><span class="line">          train_generator, #训练集迭代器</span><br><span class="line">          steps_per_epoch=len(train_generator), #每个周期需要迭代多少步</span><br><span class="line">          epochs=EPOCHS, #迭代周期</span><br><span class="line">          validation_data=test_generator, #测试集迭代器</span><br><span class="line">          validation_steps=len(test_generator) #测试集迭代多少步</span><br><span class="line">          )</span><br><span class="line">model.save(&#x27;&#123;&#125;.h5&#x27;.format(SAVE_PATH)) #保存模型</span><br><span class="line">print(&#x27;finish &#123;&#125; epochs!&#x27;.format(EPOCHS))</span><br></pre></td></tr></table></figure><h4 id="把深度学习通用的这些术语先了解一下"><a href="#把深度学习通用的这些术语先了解一下" class="headerlink" title="把深度学习通用的这些术语先了解一下"></a>把深度学习通用的这些术语先了解一下</h4><ol><li>batchsize</li><li>epoch</li><li>lables</li><li>loss </li><li>validation </li><li>relu </li><li>optimatize </li><li>线性梯度下降</li></ol><h4 id="卷积核、滤波器"><a href="#卷积核、滤波器" class="headerlink" title="卷积核、滤波器"></a>卷积核、滤波器</h4><p>MG_W,IMG_H,3),filters&#x3D;32,kernel_size&#x3D;3,padding&#x3D;’same’,activation&#x3D;’relu’))<br>比如这个 卷积核是3 滤波器32 这里面的参数先了解一下 具体作用后面带你们学</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>最近正好做 男女儿童的分类，举个具体的例子解释一下：<br>假设 儿童5w, 识别成儿童的有4w， 识别成other 的有1w.<br>other10w, 识别成other的有8w, 识别成儿童的有 2w<br>下面分析儿童的准确率和召回率，那么按照给出的信息分析下面表格：<br>儿童相关数据 —————————————————–儿童不相关数据<br>检索到儿童是儿童的数据并识别为儿童 —————- 把other识别成儿童<br>（正类识别为正类， TP&#x3D;4w）———————（负类识别为正类，FP&#x3D;2w）<br>未检索到儿童是儿童数据却识别为other—————把other识别为 other<br>(正类识别为负类， FN&#x3D; 1w) ————————– (负类识别为负类， TN&#x3D;8w)</p><h4 id="准确率-accuracy"><a href="#准确率-accuracy" class="headerlink" title="准确率 accuracy:"></a>准确率 accuracy:</h4><p>准确率是我们最常见的评价指标，而且很容易理解，就是被分对的样本数除以所有的样本数，通常来说，正确率越高，分类器越好。</p><p>accuracy &#x3D; (4+8)&#x2F;(4+2+1+8)&#x3D;80%</p><h4 id="精确率-precision："><a href="#精确率-precision：" class="headerlink" title="精确率 precision："></a>精确率 precision：</h4><p>你认为的该类样本，有多少猜对了（猜的精确性如何）。可以解释为，在所有判别为儿童的数据中是儿童的数据的比例.TP表示是真正分类正确的数量。分母TP+FP表示被识别成儿童的总数</p><p>precision &#x3D; TP &#x2F;（TP + FP） &#x3D; 66.67%</p><h4 id="召回率-recall："><a href="#召回率-recall：" class="headerlink" title="召回率 recall："></a>召回率 recall：</h4><p>召回率可解释为， 在所有儿童相关的数据中，判别为儿童的数据的比例：<br>通俗对的解释就是，本来该有5W个儿童，算法召回了多少。<br>recall &#x3D; TP &#x2F; (TP + FN) &#x3D; 80%</p><h4 id="F-score-x3D-精确率-召回率-2-x2F-精确率-召回率"><a href="#F-score-x3D-精确率-召回率-2-x2F-精确率-召回率" class="headerlink" title="F-score &#x3D;精确率 * 召回率 * 2 &#x2F; (精确率 + 召回率)"></a>F-score &#x3D;精确率 * 召回率 * 2 &#x2F; (精确率 + 召回率)</h4><p>f-score &#x3D;(0.667*0.8)*2&#x2F;(0.667+0.8) &#x3D; 72.8%</p><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>TP: 将正类预测为正类数<br>FN: 将正类预测为负类数<br>FP: 将负类预测为正类数<br>TN: 将负类预测为负类数</p><p>准确率(accuracy) &#x3D; 预测对的&#x2F;所有 &#x3D; (TP+TN)&#x2F;(TP+FN+FP+TN)<br>精确率(precision) &#x3D; TP&#x2F;(TP+FP)<br>召回率(recall) &#x3D; TP&#x2F;(TP+FN)<br>f-score &#x3D; 精确率 * 召回率 * 2 &#x2F; (精确率 + 召回率)</p>]]></content>
      
      
      <categories>
          
          <category> DeepLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql学习笔记</title>
      <link href="/post/7f3b056.html"/>
      <url>/post/7f3b056.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、mySQL锁"><a href="#一、mySQL锁" class="headerlink" title="一、mySQL锁"></a>一、mySQL锁</h1><blockquote><p>数据库隐式帮我们添加了锁:</p><ul><li>对于<code>UPDATE、DELETE、INSERT</code>语句,InnoDB(<em>mySQL的数据库引擎之一,现为MySQL的默认存储引擎</em>)会自动将涉及的数据集添加 <strong>排他锁(X锁)</strong></li><li>事务拿到某一行记录的 <strong>共享锁(S锁)</strong> 才可以读取这一行,并阻止其他事务对其添加排他锁</li><li>事务拿到一行记录的 <strong>排他锁(X锁)</strong> 才可以修改或和删除这一行</li></ul><h5 id="共享锁的目的是为了提高读取的并发-排他锁的目的时为了保证数据的一致性"><a href="#共享锁的目的是为了提高读取的并发-排他锁的目的时为了保证数据的一致性" class="headerlink" title="共享锁的目的是为了提高读取的并发;排他锁的目的时为了保证数据的一致性"></a>共享锁的目的是为了提高读取的并发;排他锁的目的时为了保证数据的一致性</h5><p>我们在某些特定的场景下才需要手动进行加所,学习数据库锁知识就是为了:</p><ul><li>更好地控制程序代码</li><li>能让我们在特定场景上派上用场</li><li>构建自己的数据库知识体系</li></ul></blockquote><h2 id="1、悲观锁"><a href="#1、悲观锁" class="headerlink" title="1、悲观锁"></a>1、悲观锁</h2><blockquote><p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li><li>Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</li><li><code>共享锁</code>与<code>排他锁</code>都是<strong>悲观锁</strong>的范畴</li></ul></blockquote><h3 id="Ⅰ-注意点"><a href="#Ⅰ-注意点" class="headerlink" title="Ⅰ- 注意点"></a>Ⅰ- 注意点</h3><blockquote><p>要使用悲观锁我们就必须先关闭Mysql数据库的自动提交属性,因为Mysql默认使用 autocommit 模式</p><p>也就是说当你执行一个更新操作,Mysql会立即将结果进行提交</p><h6 id="排他锁与共享锁是悲观锁的不同实现-他们都属于悲观锁的范畴"><a href="#排他锁与共享锁是悲观锁的不同实现-他们都属于悲观锁的范畴" class="headerlink" title="排他锁与共享锁是悲观锁的不同实现,他们都属于悲观锁的范畴"></a>排他锁与共享锁是悲观锁的不同实现,他们都属于悲观锁的范畴</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新库存(使用悲观锁)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateStock</span><span class="params">(Long productId)</span>&#123;</span><br><span class="line">       <span class="comment">//先锁定商品库存记录</span></span><br><span class="line">       <span class="type">ProductStock</span> <span class="variable">product</span> <span class="operator">=</span> query(<span class="string">&quot;SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125; FOR UPDATE&quot;</span>, productId);</span><br><span class="line">       <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">updateCnt</span> <span class="operator">=</span> update(<span class="string">&quot;UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125;&quot;</span>, productId);</span><br><span class="line">           <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-排他锁"><a href="#Ⅱ-排他锁" class="headerlink" title="Ⅱ- 排他锁"></a>Ⅱ- 排他锁</h3><blockquote><p>排他锁与共享锁相对应,就是指对于多个不同事务,对同一个资源只能有一把锁,与共享锁类似,在需要执行的语句后面加上 <code>for update</code> 就可以了</p><ul><li>用域数据修改操作,例如:<code>UPDATE、DELETE、INSERT</code>语句.确保不会同时对同一资源进行多重更新</li><li>如果事务T对数据A加上排他锁后,则其他事务不能再对A加任何类型的封锁.</li><li>获准排他锁的数据技能读取数据还能修改数据</li></ul></blockquote><h3 id="Ⅲ-共享锁"><a href="#Ⅲ-共享锁" class="headerlink" title="Ⅲ - 共享锁"></a>Ⅲ - 共享锁</h3><blockquote><p><strong>共享锁(S锁)</strong> 用于不更改或不更新数据的操作(只读操作),例如<code>SELECT</code>语句</p><p>如果事务T对数据A加上共享锁后: <strong>其他事务只能对A再加共享锁,不能加排他锁.获准共享锁的事务只能读数据,不可修改数据</strong></p></blockquote><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><blockquote><ol><li>开启共享锁</li></ol>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> city <span class="keyword">where</span> id <span class="operator">=</span> &quot;1&quot; lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后在另一个查询窗口中对id为1的数据进行更新</li></ol>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>  city <span class="keyword">set</span> name<span class="operator">=</span>&quot;努力学习的汪&quot; <span class="keyword">where</span> id <span class="operator">=</span>&quot;1&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>此时操作界面进入了卡顿状态,过了几秒也提示错误信息</li></ol>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">SQL</span>]<span class="keyword">update</span>  city <span class="keyword">set</span> name<span class="operator">=</span>&quot;努力学习的汪&quot; <span class="keyword">where</span> id <span class="operator">=</span>&quot;1&quot;;</span><br><span class="line">[Err] <span class="number">1205</span> <span class="operator">-</span> Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><ol start="4"><li>如此就证明对于 <code>id=1</code> 的记录枷锁成功了:</li></ol><blockquote><p>在上一条记录还没有commmit之前,这条 <code>id=1</code>的记录被锁住了,只有在上一个事务书房掉锁后才能进行操作,或用共享锁才能对此数据进行操作</p></blockquote></blockquote><h2 id="2、乐观锁"><a href="#2、乐观锁" class="headerlink" title="2、乐观锁"></a>2、乐观锁</h2><blockquote><p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p></blockquote><h3 id="Ⅰ-乐观锁的两种方式"><a href="#Ⅰ-乐观锁的两种方式" class="headerlink" title="Ⅰ - 乐观锁的两种方式"></a>Ⅰ - 乐观锁的两种方式</h3><h4 id="①-使用数据版本实现"><a href="#①-使用数据版本实现" class="headerlink" title="① 使用数据版本实现"></a>① 使用数据版本实现</h4><blockquote><h6 id="使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？"><a href="#使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？" class="headerlink" title="使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？"></a>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？</h6><ol><li>即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。</li><li>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。</li><li>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对</li><li>如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li></ol></blockquote><h4 id="②-使用时间戳（timestamp）"><a href="#②-使用时间戳（timestamp）" class="headerlink" title="② 使用时间戳（timestamp）"></a>② 使用时间戳（timestamp）</h4><blockquote><p>乐观锁定的第二种实现方式和第一种差不多:</p><ol><li>同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）</li><li>和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比</li><li>如果一致则OK，否则就是版本冲突。</li></ol></blockquote><h3 id="Ⅱ-举个栗子"><a href="#Ⅱ-举个栗子" class="headerlink" title="Ⅱ- 举个栗子"></a>Ⅱ- 举个栗子</h3><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下单减库存</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateStock</span><span class="params">(Long productId)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">updateCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (updateCnt == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">ProductStock</span> <span class="variable">product</span> <span class="operator">=</span> query(<span class="string">&quot;SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;&quot;</span>, productId);</span><br><span class="line">           <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//这里进行判断,number需要等于number才能更新</span></span><br><span class="line">               updateCnt = update(<span class="string">&quot;UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;&quot;</span>, productId, product.getNumber());</span><br><span class="line">               <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;    <span class="comment">//卖完啦</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、行锁"><a href="#3、行锁" class="headerlink" title="3、行锁"></a>3、行锁</h2><blockquote><p>行锁，由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。</p><p>比如之前的共享锁语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> city <span class="keyword">where</span> id <span class="operator">=</span> &quot;1&quot; lock <span class="keyword">in</span> share mode; </span><br></pre></td></tr></table></figure><p>由于对于city表中,id字段为主键，就也相当于索引。执行加锁时，会将id这个索引为1的记录加上锁，那么这个锁就是行锁。</p><p>除此之外还有表锁,但不进行深入研究记录</p></blockquote><h3 id="Ⅰ-InnoDB引擎的数据库状态查看（分析行锁）"><a href="#Ⅰ-InnoDB引擎的数据库状态查看（分析行锁）" class="headerlink" title="Ⅰ - InnoDB引擎的数据库状态查看（分析行锁）"></a>Ⅰ - InnoDB引擎的数据库状态查看（分析行锁）</h3><blockquote><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>对于各个状态说明如下：</p><ul><li><code>Innodb_row_lock_current_waits</code>: 当前正在等待锁的数量；</li><li><code>Innodb_row_lock_time</code>: 从系统启动到现在锁定总时间长度；</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；</li><li><code>Innodb_row_lock_time_max</code>: 从系统启动到现在等待最长的一次所花的时间长度；</li><li><code>Innodb_row_lock_waits</code>: 系统启动到现在总共等待的次数</li></ul></blockquote><h1 id="二、数据库设计"><a href="#二、数据库设计" class="headerlink" title="二、数据库设计"></a>二、数据库设计</h1><h2 id="1、数据库设计三大范式"><a href="#1、数据库设计三大范式" class="headerlink" title="1、数据库设计三大范式"></a>1、数据库设计三大范式</h2><blockquote><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><ol><li>每一列只有一个值</li><li>每一行都能区分。</li><li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ol></blockquote><h1 id="三、Mysql相关的问题与解答"><a href="#三、Mysql相关的问题与解答" class="headerlink" title="三、Mysql相关的问题与解答"></a>三、Mysql相关的问题与解答</h1><h2 id="1、MyISAM索引底层是什么结构-–B-Tree"><a href="#1、MyISAM索引底层是什么结构-–B-Tree" class="headerlink" title="1、MyISAM索引底层是什么结构? –B+ Tree"></a>1、MyISAM索引底层是什么结构? –<code>B+ Tree</code></h2><blockquote><h6 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a><code>B+ Tree</code></h6><p><strong>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</strong>。而在InnoDB中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引</p></blockquote><h2 id="2、MySQL如何解决脏读、不可重复读、幻读"><a href="#2、MySQL如何解决脏读、不可重复读、幻读" class="headerlink" title="2、MySQL如何解决脏读、不可重复读、幻读"></a>2、MySQL如何解决脏读、不可重复读、幻读</h2><h3 id="Ⅰ-脏读"><a href="#Ⅰ-脏读" class="headerlink" title="Ⅰ - 脏读"></a>Ⅰ - 脏读</h3><blockquote><h6 id="什么是脏读"><a href="#什么是脏读" class="headerlink" title="什么是脏读?"></a>什么是脏读?</h6><p>脏读是指一个事务中访问到了另外一个事务未提交的数据</p><ul><li>如果会话2更新age到10,但是在commit之前会话1希望得到age: 那么会获得的值就是更新前的值</li><li>或者会话2更新了值但是执行了 <code>rollback</code>,而会话1拿到的仍是10,这就是脏读</li></ul></blockquote><h3 id="Ⅱ-幻读"><a href="#Ⅱ-幻读" class="headerlink" title="Ⅱ - 幻读"></a>Ⅱ - 幻读</h3><blockquote><p>一个事务读取2次,得到的记录条数不一致</p><p>上图很明显的表示了这个情况，由于在会话 1 之间插入了一个新的值，所以得到的两次数据就不一样了</p></blockquote><h3 id="Ⅲ-不可重复读"><a href="#Ⅲ-不可重复读" class="headerlink" title="Ⅲ - 不可重复读"></a>Ⅲ - 不可重复读</h3><blockquote><p>一个事务读取同一条记录2次,得到的结果不一致</p><p>由于在读取中间变更了数据，所以会话 1 事务查询期间的得到的结果就不一样了</p></blockquote><h3 id="Ⅳ-解决方案"><a href="#Ⅳ-解决方案" class="headerlink" title="Ⅳ - 解决方案"></a>Ⅳ - 解决方案</h3><blockquote><p>解决方案即是下面四种隔离级别,他们可以最大程度避免以上三种情况的发生</p></blockquote><h2 id="3、MySQL-数据隔离级别"><a href="#3、MySQL-数据隔离级别" class="headerlink" title="3、MySQL 数据隔离级别"></a>3、MySQL 数据隔离级别</h2><blockquote><p>MySQL 里有四个隔离级别：</p><ol><li>Read uncommttied(可以读取未提交数据)–未授权读取</li><li>Read committed(可以读取已提交数据) –授权读取</li><li>Repeatable read(可重复读) –可重复读取</li><li>Serializable(可串行化) –序列化</li></ol><h6 id="在-InnoDB-中，默认为-Repeatable-级别，InnoDB-中使用一种被称为-next-key-locking-的策略来避免幻读-phantom-现象的产生"><a href="#在-InnoDB-中，默认为-Repeatable-级别，InnoDB-中使用一种被称为-next-key-locking-的策略来避免幻读-phantom-现象的产生" class="headerlink" title="在 InnoDB 中，默认为 Repeatable 级别，InnoDB 中使用一种被称为 next-key locking 的策略来避免幻读(phantom)现象的产生"></a>在 InnoDB 中，默认为 Repeatable 级别，InnoDB 中使用一种被称为 next-key locking 的策略来避免幻读(phantom)现象的产生</h6><p>不同的事务隔离级别会导致不同的问题：</p></blockquote><h3 id="Ⅰ-Read-uncommttied–未授权读取"><a href="#Ⅰ-Read-uncommttied–未授权读取" class="headerlink" title="Ⅰ - Read uncommttied–未授权读取"></a>Ⅰ - Read uncommttied–未授权读取</h3><blockquote><p>也称为读未提交(Read Uncommitted)：允许脏读取，但不允许更新丢失。</p><p>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现</p></blockquote><h3 id="Ⅱ-Read-committed–授权读取"><a href="#Ⅱ-Read-committed–授权读取" class="headerlink" title="Ⅱ - Read committed–授权读取"></a>Ⅱ - Read committed–授权读取</h3><blockquote><p>也称为读提交(Read Committed)：允许不可重复读取，但不允许脏读取。</p><p>这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。</p></blockquote><h3 id="Ⅲ-Repeatable-read–可重复读取"><a href="#Ⅲ-Repeatable-read–可重复读取" class="headerlink" title="Ⅲ - Repeatable read–可重复读取"></a>Ⅲ - Repeatable read–可重复读取</h3><blockquote><p>可重复读取(Repeatable Read)：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。</p><p>这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。</p></blockquote><h3 id="Ⅳ-Serializable–序列化"><a href="#Ⅳ-Serializable–序列化" class="headerlink" title="Ⅳ - Serializable–序列化"></a>Ⅳ - Serializable–序列化</h3><blockquote><p>序列化(Serializable)：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。</p><ul><li>仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</li><li>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</li><li>对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为<code>Read Committed(授权读取)</code>。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</li></ul></blockquote><h1 id="四、常见的报错与解决"><a href="#四、常见的报错与解决" class="headerlink" title="四、常见的报错与解决"></a>四、常见的报错与解决</h1><h2 id="1、解除输入的安全模式"><a href="#1、解除输入的安全模式" class="headerlink" title="1、解除输入的安全模式"></a>1、解除输入的安全模式</h2><blockquote><ol><li><p>报错:<code>You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.  To disable safe mode, toggle the option in Preferences -&gt; SQL Editor and reconnect.0.000 sec</code></p></li><li><p>这是因为MySql运行在safe-updates模式下，该模式会导致非主键条件下<code>无法执行update或者delete命令</code>。</p></li><li><p>show variables like ‘SQL_SAFE_UPDATES’;查看开关状态。</p></li><li><p>执行命令SET SQL_SAFE_UPDATES &#x3D; 0;修改下数据库模式</p></li><li><p>至此可以正常修改了</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql进阶 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
